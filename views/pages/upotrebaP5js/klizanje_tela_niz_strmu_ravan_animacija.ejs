<!DOCTYPE html>
<html lang="sr">
<head>
    <% include ../partials/head %>
	<title>Klizanje tela niz strmu ravan</title>
	
  <meta name="description" content="Kružna animacija u p5.js uz vizuelizaciju kretanja tela niz strmu ravan.">
  <link rel="canonical" href="https://kosi-hitac.onrender.com/klizanje_tela_niz_strmu_ravan" />
  
   <style>
  
    #sketch-holder {
      width: 100%;
      max-width: 600px;
      margin: 20px auto;
      
    }
	 .p5Canvas{
	  width: 600px;
  height: 400px;
      border: solid thin #0000ff;
      margin-bottom:auto;
    }
  </style>
</head>
<body>
  <div class="container d-flex flex-column align-items-start justify-content-center mb-3">
    <div class="row">
      <div class="col-xs-12">
        <header>
          <% include ../partials/header %>
        </header>
      </div>
    </div>

    <div class="row">
      <div class="naslov col-xs-12">
        <h1>Klizanje tela niz strmu ravan</h1>
      </div>
      <hr>
    </div>

    <div class="row">
      <div class="moj_tekst col-xs-12">
        <p>
          Klizanje tela niz strmu ravan je klasičan problem iz dinamike u fizici. 
          Kada telo klizi po ravni koja zaklapa ugao <code>α</code> sa horizontalom, 
          komponenta gravitacione sile duž ravni je <code>m·g·sin(α)</code>. 
          Ako zanemarimo trenje, ubrzanje tela je:
        </p>
        <p style="text-align: center;"><strong>a = g·sin(α)</strong></p>
        <p>
          U realnim uslovima često se uvodi koeficijent trenja <code>μ</code>, pa se 
          rezultujuća sila duž ravni smanjuje za <code>μ·m·g·cos(α)</code>, 
          a ubrzanje postaje:
        </p>
        <p style="text-align: center;"><strong>a = g·(sin(α) – μ·cos(α))</strong></p>
        <h2>Simulacija u Processing‑u</h2>
        <p>
          Za interaktivnu simulaciju klizanja tela niz strmu ravan u Processing‑u, pogledajte primer:
          <a href="https://www.svetprogramiranja.com/primer_strma_ravan_u_processingu.html" target="_blank">
            Primer strma ravan u Processing‑u
          </a>.
        </p>
        
        <h2>Resursi</h2>
        <ul>
          <li><a href="https://p5js.org/" target="_blank">p5.js zvanični sajt</a></li>
          <li><a href="https://processing.org/" target="_blank">Processing zvanični sajt</a></li>
          <li><a href="https://www.svetprogramiranja.com/primer_strma_ravan_u_processingu.html" target="_blank">Primer strma ravan u Processing‑u</a></li>
          <li><a href="https://www.um.es/fem/EjsWiki/Main/Download" target="_blank">Easy Java Simulation (EJS)</a></li>
          <li><a href="https://www.compadre.org/osp/" target="_blank">Open Source Physics (OSP)</a></li>
        </ul>
      </div>
    </div>
	
	<div class="moj_tekst">
  <h3 class="okvir_3">Teorija: Sile na nagnutoj ravni</h3>
  <p>
    Na telo mase <code>m</code> koje leži na ravni nagnutoj pod uglom <code>α</code> deluju sledeće sile:
  </p>
  <ul>
    <li><strong>Težina</strong> <code>Q = m·g</code>, usmerena vertikalno naniže.</li>
    <li><strong>Komponenta težine paralelna ravan</strong>  
      <code>Qₓ = Q·sin(α) = m·g·sin(α)</code>, usmerena naniže duž ravni.</li>
    <li><strong>Komponenta težine normalna na ravan</strong>  
      <code>Qᵧ = Q·cos(α) = m·g·cos(α)</code>, usmerena u ravni prema unutra.</li>
    <li><strong>Normalna sila</strong> <code>N = Qᵧ = m·g·cos(α)</code>, suprotna <code>Qᵧ</code>.</li>
    <li><strong>Trenje</strong> <code>Fₜᵣ = μ·N = μ·m·g·cos(α)</code>, suprotno smeru klizanja.</li>
  </ul>

  <p style="text-align:center;">
    <img src="/images/StrmaRavan/StrmaRavanTelo.jpg" 
         alt="Telo na nagnutoj ravni sa silama" 
         style="max-width:100%; height:auto; border:1px solid #ccc;">
  </p>

  <p>
    U simulaciji računamo akceleraciju duž ravni kao razliku paralelne komponente težine i trenja, podeljenu sa masom:
  </p>
  <pre><code>
a = (Qₓ – Fₜᵣ) / m 
  = [m·g·sin(α) – μ·m·g·cos(α)] / m
  = g·sin(α) – μ·g·cos(α)
  </code></pre>

  <p>
    Pozicija <code>x(t)</code> i brzina <code>v(t)</code> duž ravni dobijaju se standardnim kinematičkim izrazima:
  </p>
  <pre><code>
x(t) = x₀ + v₀·t + ½·a·t²
v(t) = v₀ + a·t
  </code></pre>

  <p>
    Ovako definisani izrazi ulaze u p5.js petlju <code>draw()</code>, gde se u svakoj iteraciji 
    ažuriraju položaj i brzina tela po formuli iznad, a zatim se sve sile crtaju kao strelice u centru bloka.
  </p>
</div>

<div class="moj_tekst">
  <div class="col-12">
    <h2>Animacija klizanja tela niz strmu ravan pomoću alata p5.js</h2>

    <p>
      Ova animacija prikazuje kako blok klizi niz nagib pod uglom <code>α</code> koristeći JavaScript biblioteku 
      <strong>p5.js</strong>. U centru bloka crtaju se sile:
      <code>Qₓ</code> (paralelna komponenta težine), <code>Qᵧ</code> (normalna komponenta), 
      <code>N</code> (normalna sila) i <code>Fₜᵣ</code> (trenje).
    </p>

    <p>
      U svakoj iteraciji izračunavamo ubrzanje
      <code>a = g·sin(α) – μ·g·cos(α)</code>, ažuriramo brzinu i položaj bloka, i crtamo
      strelice koje predstavljaju sve sile. Kada blok stigne do kraja ravni, animacija se kratko zaustavlja,
      blok se vraća u početni položaj i proces se ponavlja.
    </p>

    <h3>Primer animacije:</h3>
    
    <div id="sketch-holder"></div>
    <p class="mt-4">
      U nastavku možete dodati kontrole za ugao nagiba, koeficijent trenja ili početnu brzinu bloka, 
      kako biste eksperimentisali sa ponašanjem simulacije.
    </p>
  </div>
</div>


<div class="moj_tekst">
  <p>Ova simulacija prikazuje klizanje tela niz strmu ravan i koristi biblioteku <strong>p5.js</strong>. Prikazani su i vektori sila koji deluju na telo: težina (<code>Q</code>), njene komponente (<code>Qₓ</code> i <code>Qᵧ</code>), normalna sila (<code>N</code>) i sila trenja (<code>Fₜᵣ</code>).</p>

  <p><strong>Parametri simulacije</strong> su definisani kao globalne promenljive: ugao nagiba, početna pozicija bloka, veličina bloka, gravitaciono ubrzanje i koeficijent trenja. U <code>setup()</code> funkciji kreira se canvas i smešta se u <code>div</code> sa ID-jem <code>sketch-holder</code>.</p>

  <p>Koordinatni sistem je rotiran tako da <code>x</code> osa prati nagib, što omogućava jednostavnije izračunavanje položaja tela i komponenti sila. Funkcije <code>translate()</code>, <code>rotate()</code>, <code>push()</code> i <code>pop()</code> koriste se za lokalnu transformaciju sistema i vraćanje na prethodno stanje nakon crtanja pojedinačnih elemenata.</p>

  <p><strong>Struktura koda</strong> je podeljena u više funkcija:</p>
  <ul>
    <li><code>drawIncline()</code> — crta nagib</li>
    <li><code>drawBlockAndForces()</code> — crta telo i vektore sila</li>
    <li><code>updateMotion()</code> — izračunava pomeraj tela uz simulaciju trenja</li>
    <li><code>drawArrow()</code> — pomoćna funkcija za crtanje strelica</li>
  </ul>
</div>

<div class="moj_kod">
<pre><code><span class="kom">// index.html</span>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html&gt;</span>
<span class="tag">&lt;head&gt;</span>
  <span class="tag">&lt;meta</span> charset="utf-8" <span class="tag">/&gt;</span>
  <span class="tag">&lt;meta</span> name="viewport" content="width=device-width, initial-scale=1.0" <span class="tag">/&gt;</span>
  <span class="tag">&lt;script</span> src="libraries/p5.min.js" <span class="tag">&gt;&lt;/script&gt;</span>
  <span class="tag">&lt;script</span> src="StrmaRavanOsnovnaSaVektorima.js" <span class="tag">&gt;&lt;/script&gt;</span>
  <span class="tag">&lt;style&gt;</span>
    body { margin: 0; padding: 0; }
    #sketch-holder {
      width: 100%;
      max-width: 600px;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
  <span class="tag">&lt;/style&gt;</span>
<span class="tag">&lt;/head&gt;</span>
<span class="tag">&lt;body&gt;</span>
  <span class="tag">&lt;div</span> id="sketch-holder"<span class="tag">&gt;&lt;/div&gt;</span>
<span class="tag">&lt;/body&gt;</span>
<span class="tag">&lt;/html&gt;</span>
</code></pre>
</div>

<div class="moj_kod">
<pre><code><span class="kom">// StrmaRavanOsnovnaSaVektorima.js</span>
<span class="rez">let</span> alpha;
<span class="rez">const</span> blockSize = <span class="broj">50</span>;
<span class="rez">const</span> g = <span class="broj">9.81</span>;
<span class="rez">const</span> mu = <span class="broj">0.2</span>;

<span class="rez">let</span> a, v = <span class="broj">0</span>, s = <span class="broj">0</span>;
<span class="rez">const</span> dt = <span class="broj">1</span>/<span class="broj">60</span>;

<span class="rez">const</span> startX = <span class="broj">150</span>;
<span class="rez">let</span> inclineY, maxS;

<span class="rez">let</span> state = <span class="str">'running'</span>, pauseStart = <span class="broj">0</span>;
<span class="rez">const</span> pauseDuration = <span class="broj">1000</span>;

<span class="funk">function</span> setup() {
  <span class="rez">const</span> canvas = createCanvas(<span class="broj">600</span>, <span class="broj">400</span>);
  canvas.parent(<span class="str">'sketch-holder'</span>);
  
  alpha = PI/<span class="broj">6</span>;
  inclineY = height/<span class="broj">3</span>;
  maxS = width - startX;

  a = g * sin(alpha) - mu * g * cos(alpha);

  angleMode(RADIANS);
  rectMode(CENTER);
  textAlign(LEFT, CENTER);
}

<span class="funk">function</span> draw() {
  background(<span class="broj">240</span>);
  drawIncline();
  updateMotion();
  drawBlockAndForces();
}

<span class="funk">function</span> updateMotion() {
  <span class="rez">if</span> (state === <span class="str">'running'</span>) {
    v += a * dt;
    s += v * dt;
    <span class="rez">if</span> (s >= maxS) {
      s = maxS;
      state = <span class="str">'pause'</span>;
      pauseStart = millis();
    }
  } <span class="rez">else if</span> (state === <span class="str">'pause'</span>) {
    <span class="rez">if</span> (millis() - pauseStart >= pauseDuration) {
      s = <span class="broj">0</span>;
      v = <span class="broj">0</span>;
      state = <span class="str">'running'</span>;
    }
  }
}

<span class="funk">function</span> drawIncline() {
  push();
  translate(<span class="broj">0</span>, inclineY);
  rotate(alpha);
  noStroke();
  fill(<span class="broj">220</span>, <span class="broj">230</span>, <span class="broj">255</span>);
  triangle(<span class="broj">0</span>, <span class="broj">0</span>, width*<span class="broj">1.5</span>, <span class="broj">0</span>, <span class="broj">0</span>, height);
  stroke(<span class="broj">0</span>);
  strokeWeight(<span class="broj">2</span>);
  line(<span class="broj">0</span>, <span class="broj">0</span>, width*<span class="broj">1.5</span>, <span class="broj">0</span>);
  pop();
}

<span class="funk">function</span> drawBlockAndForces() {
  <span class="rez">const</span> Qx = g * sin(alpha),
        Qy = g * cos(alpha),
        N = Qy,
        Ftr = mu * N,
        scaleF = <span class="broj">20</span>;

  <span class="rez">let</span> bx = startX + s,
      by = inclineY + bx * tan(alpha);

  push();
  translate(bx, by);
  rotate(alpha);
  translate(<span class="broj">0</span>, -blockSize/<span class="broj">2</span>);

  fill(<span class="broj">200</span>);
  stroke(<span class="broj">0</span>);
  rect(<span class="broj">0</span>, <span class="broj">0</span>, blockSize, blockSize);

  drawArrow(createVector(<span class="broj">0</span>,<span class="broj">0</span>), createVector(Qx*scaleF, <span class="broj">0</span>), <span class="str">'red'</span>);
  text(<span class="str">'Qₓ'</span>, Qx*scaleF+<span class="broj">5</span>, -<span class="broj">5</span>);

  drawArrow(createVector(<span class="broj">0</span>,<span class="broj">0</span>), createVector(<span class="broj">0</span>, Qy*scaleF), <span class="str">'red'</span>);
  text(<span class="str">'Qᵧ'</span>, <span class="broj">5</span>, Qy*scaleF+<span class="broj">15</span>);

  drawArrow(createVector(<span class="broj">0</span>,<span class="broj">0</span>), createVector(Qx*scaleF, Qy*scaleF), <span class="str">'purple'</span>);
  text(<span class="str">'Q'</span>, Qx*scaleF/<span class="broj">2</span>+<span class="broj">5</span>, Qy*scaleF/<span class="broj">2</span>+<span class="broj">5</span>);

  drawArrow(createVector(<span class="broj">0</span>,<span class="broj">0</span>), createVector(<span class="broj">0</span>, -N*scaleF), <span class="str">'green'</span>);
  text(<span class="str">'N'</span>, <span class="broj">5</span>, -N*scaleF-<span class="broj">10</span>);

  drawArrow(createVector(<span class="broj">0</span>,<span class="broj">0</span>), createVector(-Ftr*scaleF, <span class="broj">0</span>), <span class="str">'orange'</span>);
  text(<span class="str">'Fₜᵣ'</span>, -Ftr*scaleF-<span class="broj">30</span>, -<span class="broj">5</span>);
  pop();
}

<span class="funk">function</span> drawArrow(base, vec, col) {
  push();
  stroke(col);
  strokeWeight(<span class="broj">3</span>);
  fill(col);
  translate(base.x, base.y);
  line(<span class="broj">0</span>, <span class="broj">0</span>, vec.x, vec.y);
  <span class="rez">const</span> arrowSize = <span class="broj">7</span>;
  push();
  translate(vec.x, vec.y);
  rotate(vec.heading());
  triangle(<span class="broj">0</span>, <span class="broj">0</span>, -arrowSize, arrowSize/<span class="broj">2</span>, -arrowSize, -arrowSize/<span class="broj">2</span>);
  pop();
  pop();
}
</code></pre>
</div>

<div class="moj_tekst">
  <h3 class="okvir_3">Objašnjenje koda animacije klizanja</h3>

  <ul>
    <li>
      <strong>Globalne promenljive:</strong>
      ugao nagiba <code>alpha</code> (pozitivno: ravan pada s leva na desno naniže),  
      pozicija centra bloka <code>blockPos</code>,  
      veličina bloka <code>blockSize</code>,  
      gravitaciono ubrzanje <code>g</code>,  
      koeficijent trenja <code>mu</code>.
    </li>
    <li>
      U <code>setup()</code> metodu:
      <ol>
        <li>Napraviti <code>createCanvas(600,400)</code> i ugraditi ga u <code>&lt;div id="sketch-holder"&gt;</code> sa <code>canvas.parent(...)</code>.</li>
        <li>Postaviti <code>alpha = PI/6</code> i izračunati startnu poziciju:
          <pre><code>startX = 150;
startY = startX * tan(alpha);
blockPos = createVector(startX, startY);</code></pre>
        </li>
        <li>Podesiti <code>angleMode(RADIANS)</code>, <code>rectMode(CENTER)</code>, <code>textAlign(LEFT,CENTER)</code>.</li>
      </ol>
    </li>
    <li>
      U <code>draw()</code> metodu:
      <ol>
        <li>Podešavanje pozadine: <code>background(240)</code>.</li>
        <li>Pozivi <code>drawIncline()</code> (linija i ispunjeni trougao) i <code>drawBlockAndForces()</code> (blok + sile).</li>
        <li>Poziv <code>updateMotion()</code> za ažuriranje brzine i položaja, pauzu i resetovanje.</li>
      </ol>
    </li>
    <li>
      Metode za crtanje koriste:
      <ul>
        <li><code>push()</code> / <code>pop()</code> — čuvanje i vraćanje transformacione matrice.</li>
        <li><code>translate(x,y)</code> — pomeranje koordinatnog sistema.</li>
        <li><code>rotate(α)</code> — rotacija koordinata.</li>
      </ul>
      … (tačkice označavaju da između push() i pop() možete kombinovati više translate/rotate poziva, a sve će se vratiti na početno stanje nakon pop()).
    </li>
    <li>
      Funkcija <code>updateMotion()</code> (ili inline kod u <code>draw()</code>) radi ovako:
      <pre><code>// ubrzanje niz ravan
blockAcc = g*sin(alpha) - mu*g*cos(alpha);
// svaka iteracija:
blockVel += blockAcc * deltaT;
blockPos.x += blockVel * deltaT;
// provera da li je blok stigao do desne ivice i pauza/reset…
</code></pre>
    </li>
  </ul>

  <p>
    Ovako definisani koraci čine kod modularnim, lakšim za razumevanje i održavanje.  
    Za detaljnije objašnjenje transformacija, pogledajte dokumentaciju p5.js za <code>push()/pop()</code>, 
    <code>translate()</code> i <code>rotate()</code>.
  </p>
</div>


    <div class="row">
      <div class="col-xs-12">
        <% include ../partials/scripts %>
        <% include ../partials/footer %>
      </div>
    </div>
  </div>
  
  <!-- p5.js CDN + sketch -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
  <script language="javascript" type="text/javascript" src="js/p5js/StrmaRavan/StrmaRavanOsnovnaSaVektorima.js"></script>
</body>
</html>
